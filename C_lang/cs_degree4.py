"""
bool - 1 byte
int - 4 (which is ~4milliarda negative + positive. so 2 billion for positive nums)
long - 8
float - 4
double - 8
char - 1
string = ?

на чипах с RAM и хранятся наши данные

не важно какого года или мощности твой пи си
смысол один и тот же - все в RAM хранится на сетке их байтсов

ARRAY - sequenceof values back to back to back in memory

int scores[3]; // array из 3х интов, судя по всему из-за строгой типизации может содержать теперь только инт.

scores[0] = 123213;
scores[1] = 213;
i td.


C не дает возможности узнать длину массива, нужно запоминать самому и задавать длину массива

комп знает когда кончается строка в памяти, потому что там есть скрытое специальное значение из нулей
00000000, все 0 биты, !!!занимает отдельную ячейку в конце!!!, собсна получается 0 байт

    ПОЭТОМУ, любая строка на деле - это n + 1 bytes.

т.к писать 8 нулей - запарно, юзают следующую нотацию - \0
С нотация, означающая 8 пустых битов

ТАКЖЕ это называется NUL, а еще этот NUL - 0 ACII char

STRING IS AN ARRAY! OF CHRS


Интересная штука, хз только в С так или нет
если выйти за пределы массива, то можно литерали вывести на экран что-то из других ячеек памяти

char myStr[] = "HI!"

myStr[4] - может вывести чет, если после этого массива есть что-то в оперативной памяти. Но это может привести к крашам, если 
заглядывать далеко
"""

"""
Чтобы твоя прога в C могла принимать Command Line args, надо в поределении ф-ции main поменять принимаемые параметры

int main(void){} => int main(int argc, string argv[]){}

argument count, argument vector(array)



EXIT STATUS - special return when program stops running. Default - 0
"""